SDE Sheet (Striver)

1 . Find the duplicate in an array of N+1 integers
     TORTOISE AND HARE APPROACH

 def findDuplicate(self, nums: List[int]) -> int:
        i = nums[0]
        j = nums[0]
        f = 0
        while f == 0:
            i = nums[i]
            j = nums[nums[j]]
            if i == j:
                f = 1
            
        c = i
        s = nums[0]
        while c != s:
            c = nums[c]
            s = nums[s]
            
        return c

Explanation of this approach : Suppose the distance between starting point "S" and start of the loop "L" is 
"F" and distance between "L" and collision point "P" is "a".Length of one loop is "C".

So,the hare would have covered twice the distance of tortoise before colliding at point "P".
This equation must satisfy:

2(F+a)=F+nC+a
which gives F+a=nC  (1)

Now,in phase two we will put the tortoise at point "S" and "Hare" at point "P".
And we will traverse both with same speed. Then they will meet at point "F".

Why ?
Since c-a+a = c
If we remove "a" from "c"(Coz we are starting from point "P").It will cover c-a distance which is exactly equal to "F" (From equation (1)).


2 . Sort an array of 0’s 1’s 2’s without using extra space or sorting algo 

def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        
        p0 = -1
        p1 = -1
        p2 = 0
        while p2 < len(nums):
            x = nums[p2]
            if x == 0:
                if p0 == p1:
                    p0 += 1
                    p1 += 1
                    nums[p0],nums[p2] = nums[p2],nums[p0]
                    
                else:
                    p0 += 1
                    p1 += 1
                    nums[p0] = 0
                    if p2 > p1:
                        nums[p1], nums[p2] = 1, nums[p1]

                    else:
                        nums[p1] = 1
                
                p2 = p2 + 1
                continue
                
            if x == 1:
                p1 += 1
                if p2 > p1:
                    nums[p1], nums[p2] = 1, nums[p1]

                else:
                    nums[p1] = 1
                
                p2 = p2 + 1
                continue
                
            p2 = p2+1
            
        return

#Explanation : Maintain two pointers acting as a wall.

3 . Find Missing And Repeating.

#Equation approach
def findTwoElement( self,arr, n): 
        # code here
        s = (n*(n+1))//2
        s2 = (n*(n+1)*((2*n)+1))//6
        som = 0
        som2 = 0
        for i in arr:
            som += i
            som2 += i**2
        
        d1 = s-som
        d2 = s2-som2
        e = d2//d1
        m = e+d1
        m = m//2
        r = e-m
        return [r,m]

#XOR APPROACH
    def findTwoElement( self,arr, n):
        e1 = 0
        for i in range(1,n+1):
            e1 = e1^i
        
        e2 = 0
        for i in arr:
            e2  = e2^i
            
        e = e1^e2
        be = bin(e)[2:]
        be = be[::-1]
        b1 = 0
        b2 = 0
        for i in arr:
            c = bin(i)[2:]
            c = c[::-1]
            if len(c) < len(be):
                b2 = b2^i
                
            else:
                if c[len(be)-1] == "1":
                    b1 = b1^i
                    
                else:
                    b2 = b2^i
                    
        for i in range(1,n+1):
            c = bin(i)[2:]
            c = c[::-1]
            if len(c) < len(be):
                b2 = b2^i
                
            else:
                if c[len(be)-1] == "1":
                    b1 = b1^i
                    
                else:
                    b2 = b2^i
        
        f = 0   
        for i in arr:
            if i == b1:
                f = 1
                break
        
        if f:
            return [b1,b2]
            
        else:
            return [b2,b1]



4 . Merge Sorted Array

#INSERTION SORT METHOD
    #TIME COMPLEXITY O(N1*N2)
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        
        i = 0
        j = 0
        if len(nums2) == 0:
            return
        
        while i < len(nums1)-len(nums2):
            if nums1[i] > nums2[j]:
                nums1[i],nums2[j] = nums2[j],nums1[i]
                k = 0
                while k < len(nums2)-1:
                    if nums2[k] > nums2[k+1]:
                        nums2[k],nums2[k+1] = nums2[k+1],nums2[k]
                        
                    else:
                        break
                        
                    k = k+1
            
            
            i = i+1
            
        cnt = 0
        for i in range(len(nums1)-len(nums2),len(nums1)):
            nums1[i] = nums2[cnt]
            cnt += 1
            
        return

#SHELL SORT METHOD
    #TIME COMPLEXITY O(NLOGN)
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        
        cnt = 0
        for i in range(len(nums1)-len(nums2),len(nums1)):
            nums1[i] = nums2[cnt]
            cnt += 1
            
        gap = math.ceil(len(nums1)/2)  #Calculation of gaps
        f = 0
        while f == 0:
            for i in range(len(nums1)):
                j = i+gap
                if j >= len(nums1):
                    break
                    
                if nums1[i] > nums1[j]:
                    nums1[i],nums1[j] = nums1[j],nums1[i]  #Swapping of elements
                    
            tg = gap
            gap = math.ceil(gap/2)
            if tg == 1:
                f = 1
            
        return

Explanation : If we are allowed to use an extra space of O(n+m) then we can take advantage of the fact that
these two arrays are sorted.So,we can use two pointers(each pointer is at the start of both the arrays) and
compare the elements at these two pointers. If the interviewer wants an optimized approach then we are gonna
tell him shell sort method. 

5 . Kadane's algorithm

    def maxSubArray(self, A):
        max_so_far = A[0]
        cur_max = A[0]
        for i in range(1,len(A)):
            cur_max = max(A[i],cur_max+A[i])
            max_so_far = max(max_so_far,cur_max)
            
        return max_so_far

6 . Merge Intervals

def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        if  len(intervals) == 1:
            return intervals
        
        i = 0
        m = intervals[i][1]
        j = i+1
        ans = []
        f = 0
        while j < len(intervals):
            if intervals[j][0] <= m:
                m = max(m,intervals[j][1])
                j = j+1
                
            else:
                ans.append([intervals[i][0],m])
                i = j
                m = intervals[i][1]
                j = i+1
                
            
        ans.append([intervals[i][0],m])        
        return ans

7 . SET MATRIX ZEROES

def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        
        c = matrix[0][0]                           #So,what is happening here?
        for i in range(len(matrix)):                The variable 'c' stores whether first column contains zero or
            for j in range(len(matrix[i])):         not and the variable 'cd' contains whether element at first
                if matrix[i][j] == 0:               row and first column contains zero or not(This will help us to 
                    if j == 0:                      determine whether we have to set 0 to the first row. 
                        c = 0
                        
                    else:
                        matrix[0][j] = 0
                        
                    matrix[i][0] = 0
                    
        
        cd = 0
        if matrix[0][0] == 0:
            cd = 1
            
        for i in range(1,len(matrix)):
            if matrix[i][0] == 0:
                for j in range(len(matrix[i])):
                    matrix[i][j] = 0
                    
        for i in range(len(matrix[0])):
            if (i == 0 and c == 0) or (matrix[0][i] == 0 and i != 0):
                for j in range(len(matrix)):
                    matrix[j][i] = 0
                    
        if cd == 1:
            for j in range(len(matrix[0])):
                    matrix[0][j] = 0
                    
                    
        return

Explanation : The first approach is that you are gonna ask the interviewer the range of the number of the matrix.
For example all the elements of the matrix are greater than equal to zero.So,you can assign -1 to the values 
that will change(Note you will not change the zeroes that are encountered while traversal because those zeroes may effect
other rows and columns).After the traversal is done you are gonna change all the -1 to 0.
The second approach uses two dummy arrays and it is quite trivial.


8 . Pascal's Triangle

def generate(self, numRows: int) -> List[List[int]]:
        n = numRows
        if n == 0:
            return []
        
        if n == 1:
            return [[1]]
        
        if n == 2:
            return [[1],[1,1]]
        
        l = [[1],[1,1]]
        for i in range(3,n+1):
            c = l[-1]
            o = [1]
            for j in range(len(c)-1):
                o.append(c[j]+c[j+1])
                
            o.append(1)
            l.append(o)
            
        return l


#Also, Every entry in a line is value of a Binomial Coefficient. The value of ith entry in line number line is C(line, i).

9. Next Permutation

def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if len(nums) == 1:
            return
        
        
        f = 0
        for i in range(len(nums)-1):
            if nums[i] < nums[i+1]:
                f = 1
                break
                
                
        if not f:
            k = 0
            b = len(nums)-1
            while k < b:
                nums[k],nums[b] = nums[b],nums[k]
                b -= 1
                k += 1
            
            return
        
        else:
            i = len(nums)-2
            while i > -1:
                if nums[i] < nums[i+1]:
                    j = len(nums)-1
                    while j > i:
                        if nums[j] > nums[i]:
                            nums[i],nums[j] = nums[j],nums[i]
                            k = i+1
                            b = len(nums)-1
                            while k < b:
                                nums[k],nums[b] = nums[b],nums[k]
                                b -= 1
                                k += 1
                                
                            break
                            
                        j -= 1
                        
                    break
                    
                i -= 1
                
            return

10 . Find Inverses

long long int merge(long long int arr[],long long int l,long long int m,long long int r)
{
    long long int cnt = 0;
    long long int n1 = m - l + 1;
    long long int n2 = r - m;
    long long int L[n1], R[n2];
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
        
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
 
    long long int i = 0;
    long long int j = 0;
    long long int k = l;
 
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            cnt = cnt+(n1-i);
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
    return cnt;
}

long long int mergeSort(long long int arr[],long long int l,long long int r){
    if(l>=r){
        return 0;
    }
    long long int m = (l+r-1)/2;
    long long cnt,cnt1,cnt2;
    cnt1 = mergeSort(arr,l,m);
    cnt2 = mergeSort(arr,m+1,r);
    cnt = cnt1+cnt2+merge(arr,l,m,r);
    return cnt;
}

long long int inversionCount(long long int arr[], long long int N)
{
    long long int cnt;
    cnt = mergeSort(arr,0,N-1);
    return cnt;
}

11 . Best Time to Buy and Sell Stock

 def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        mi = 10**9
        ma = 0
        for i in prices:
            mi = min(mi,i)
            ans = max(ans,i-mi)
            
        return ans

12 . Rotate Matrix

def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n):
            for j in range(i,n):
                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]
                
        for i in range(n):
            p1 = 0
            p2 = n-1
            while p1 < p2:
                matrix[i][p1],matrix[i][p2] = matrix[i][p2],matrix[i][p1]
                p1 += 1
                p2 -= 1
                
        return

13 . Search in a sorted 2D matrix

def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        low = 0
        mat = matrix
        high = len(mat)-1
        x = target
        f = 0
        while low <= high and f == 0:
            mid = (low+high)//2
            if mat[mid][0] > x:
                high = mid-1
                
            else:
                low1 = 0
                high1 = len(mat[0])-1
                while low1 <= high1 and f == 0:
                    mid1 = (low1+high1)//2
                    if mat[mid][mid1] == x:
                        f = 1
                        
                    if mat[mid][mid1] < x:
                        low1 = mid1+1
		                
                    if mat[mid][mid1] > x:
                        high1 = mid1-1
                        
                        
                if not f:
                    low = mid+1
                    
        if f:
            return 1
        
        return 0

14 . Pow(x,n)

def myPow(self, x: float, n: int) -> float:
        if n >= 0:
            ans = 1
            while n > 0:
                if n%2 == 1:
                    ans = ans*x
                
                x = x*x
                n = n//2
            
            return ans
        
        else:
            ans = 1
            p = 1/x
            n = -1*n
            while n > 0:
                if n%2 == 1:
                    ans = ans*p
                    
                p = p*p
                n = n//2
                
            return ans

15 . Majority element > n//2

def majorityElement(self, nums: List[int]) -> int:
        #The majority element always exist.
        cnt = 0
        e = 0
        for i in nums:
            if cnt == 0:
                e = i
                
            if e == i:
                cnt += 1
                
            if e != i:
                cnt -= 1
                
        return e

16 . Majority element > n//3

#The intuition behind this algorithm is:
For example let's say suppose the array has two majority elements.
Then after the iteration the cnt of both should be left.

Let's say we have only one majority element.
Then also then one count will allways remain.

def majorityElement(self, nums: List[int]) -> List[int]:
        e1 = 10**18
        e2 = 10**18
        cnt1 = 0
        cnt2 = 0
        n = len(nums)
        for i in nums:
            if i == e1:
                cnt1 += 1
                
            elif i == e2:
                cnt2 += 1
                
            elif cnt1 == 0:
                e1 = i
                cnt1 = 1
                
            elif cnt2 == 0:
                e2 = i
                cnt2 = 1
                
            else:
                cnt1 -= 1
                cnt2 -= 1
                
        c1 = 0
        c2 = 0
        for i in nums:
            if i == e1:
                c1 += 1
                
            if i == e2:
                c2 += 1
            
        l = []
        if c1 > n//3:
            l.append(e1)
            
        if c2 > n//3:
            l.append(e2)
            
        return l

17 . Grid Path

#Combionatrics approach
def uniquePaths(self, m: int, n: int) -> int:
        return math.factorial(m+n-2)//(math.factorial(m-1)*math.factorial(n-1))

18 . Reverse Pairs

int merge(vector<int>& arr, int l, int m, int r)
{
    int cnt = 0;
    int n1 = m - l + 1;
    int n2 = r - m;
    int L[n1], R[n2];
    // cout << "_____________________\n";
    for (int i = 0; i < n1; i++) {
        L[i] = arr[l + i];
        // cout << L[i] << "\n";

    }
    // cout << "HI1\n";
    for (int j = 0; j < n2; j++) {
        R[j] = arr[m + 1 + j];
        // cout << R[j] << "\n";
    }
    // cout << "HI2\n";
    int i = 0;
    int j = 0;
    while (i < n1) {
        while (j < n2 && L[i] > (long long int)2 * R[j]) {
            j = j + 1;
        }
        i = i + 1;
        cnt = cnt + j;
    }


    // int i = 0;
    // int j = 0;
    i = 0;
    j = 0;
    int k = l;
    while (i < n1 && j < n2) {
        if (L[i] < R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
    // cout << "cnt " << cnt << "\n";
    return cnt;
}

int mergeSort(vector<int>& arr, int l, int r) {
    if (l >= r) {
        return 0;
    }
    int m = (l + r - 1) / 2;
    int cnt, cnt1, cnt2;
    cnt1 = mergeSort(arr, l, m);
    cnt2 = mergeSort(arr, m + 1, r);
    cnt = cnt1 + cnt2 + merge(arr, l, m, r);
    return cnt;
}

int reversePairs(vector<int>& nums) {
    int N, ans;
    N = nums.size();
    ans = mergeSort(nums, 0, N - 1);
    return ans;
}

19 . 2 Sum

def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        f = -1
        for i in range(len(nums)):
            x = nums[i]
            e = target-x
            if e in d:
                f = d[e]
                break
                
            d[x] = i
            
        return [i,f]

20 . 4 Sum

def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        ans = []
        n = len(nums)
        nums.sort()
        i = 0
        while i < n:
            j = i+1
            while j < n:
                l = j+1
                r = n-1
                x = target-(nums[i]+nums[j])
                while l < r:
                    if nums[l]+nums[r] < x:
                        l = l+1
                        
                    elif nums[l]+nums[r] > x:
                        r = r-1
                        
                    else:
                        ans.append([nums[l],nums[r],nums[i],nums[j]])
                        l = l+1
                        while l < n and nums[l] == nums[l-1]:
                            l = l+1
                            
                        r = r-1
                        while r > -1 and nums[r] == nums[r+1]:
                            r = r-1
                
                j = j+1
                while j < n and nums[j] == nums[j-1]:
                    j = j+1
            
            i = i+1
            while i < n and nums[i] == nums[i-1]:
                i = i+1
                
        return ans

21 . Longest consecutive sequence

def longestConsecutive(self, nums: List[int]) -> int:
        d = {}
        for i in nums:
            if i in d:
                d[i] += 1
                
            else:
                d[i] = 1
                
        ans = 0
        for i in nums:
            if i-1 in d:
                continue
                
            else:
                cnt = 0
                x = i
                while x in d:
                    x = x+1
                    cnt += 1
                    
                x = x-1
                ans = max(ans,cnt)
                
        return ans

****************************************************
#Sum of all sub arrays
def SubArraySum(arr, n ): 
    result = 0
  
    # computing sum of subarray  
    # using formula 
    for i in range(0, n): 
        result += (arr[i] * (i+1) * (n-i)) 
  
    # return all subarray sum 
    return result

22 . Largest subarray with 0 sum

def maxLen(n, arr):
    d = {}
    som = 0
    ans = 0
    for i in range(n):
        som += arr[i]
        if som == 0:
            ans = max(ans,i+1)
            
        else:
            if som in d:
                e = d[som]
                ans = max(ans,i-e)
                
            if som not in d:
                d[som] = i
                
    return ans

23 . Count number of subarrays with given xors

def solve(self, A, B):
        d = {0 : 1}
        som = 0
        ans = 0
        for i in A:
            som = som^i
            x = som^B
            if x in d:
                ans += d[x]
                
            if som in d:
                d[som] += 1
                
            else:
                d[som] = 1
                
        return ans

24 . Longest Substring Without Repeating Characters

 def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s) == 0:
            return 0
        
        d = {}
        i = 0
        j = 0
        ans = 0
        n = len(s)
        while i < n and j < n:
            # print(i,j)
            # print(d)
            x = s[j]
            if x in d:
                if d[x] == 0:
                    d[x] += 1
                    ans = max(ans,j-i+1)
                    j = j+1
                    
                else:
                    while i <= j and d[x] > 0:
                        d[s[i]] -= 1
                        i = i+1
                        
                    ans = max(ans,j-i+1)
                    d[x] += 1
                    j = j+1
            
            else:
                d[x] = 1
                ans = max(ans,j-i+1)
                j = j+1
            
        return ans

25 . Reverse a linked list
#Iterative
def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        while head != None:
            temp = head.next
            head.next = prev
            prev = head
            head = temp
            
        return prev

#Recursive
def reverseList(self, head: ListNode) -> ListNode:
        def rec(head):
            if head == None:
                return
            
            if head.next == None:
                w[0] = head
                return head
            
            else:
                e = rec(head.next)
                e.next = head
                head.next = None
                return head
                
        w = [head]        
        rec(head)
        return w[0]

        
        
26. Middle of the Linked List

#Tortoise and Hare approach
def middleNode(self, head: ListNode) -> ListNode:
        h1 = head
        h2 = head
        f = 0
        while f == 0:
            if h1.next == None:
                f = 1
                break
            
            if h1.next.next == None:
                h2 = h2.next
                f = 1
                break
                
            h2 = h2.next
            h1 = h1.next.next
        
        return h2

27 . Merge two sorted linked list

def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 == None and l2 == None:
            return None
        
        if l1 == None:
            return l2
        
        if l2 == None:
            return l1
        
        if l1.val <= l2.val:
            t = l1.next
            l1.next = None
            h = l1
            e = h
            l1 = t
            # h = h.next
            
        else:
            t = l2.next
            l2.next = None
            h = l2
            e = h
            l2 = t
            # h = h.next
                
        while l1 != None and l2 != None:
            # print(h.val)
            if l1.val <= l2.val:
                t = l1.next
                l1.next = None
                h.next = l1
                h = h.next
                l1 = t
                
            else:
                t = l2.next
                l2.next = None
                h.next = l2
                l2 = t
                h = h.next
                
        while l1 != None:
            t = l1.next
            l1.next = None
            h.next = l1
            h = h.next
            l1 = t
            
        while l2 != None:
            t = l2.next
            l2.next = None
            h.next = l2
            l2 = t
            h = h.next
            
        return e

28 . Remove nth node from a linked list

def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        cnt = 0
        h = head
        while head != None:
            head = head.next
            cnt += 1
            
        e = cnt-n+1
        if e == 1:
            h = h.next
            return h
        
        else:
            r = h
            cnt = 0
            while cnt < e-2:
                # print(h.val)
                h = h.next
                cnt += 1
            
            # print(h.val)
            h.next = h.next.next
            return r
                
def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        #Optimised approach
        start = ListNode()
        start.next = head
        s = start
        f = start
        print(s.val)
        cnt = 1
        while cnt <= n:
            print(f.val)
            f = f.next
            cnt += 1
        
        if f.next == None:
            return head.next
            
        while f.next != None:
            s = s.next
            f = f.next
            
        s.next = s.next.next
        return head

29 . Delete Node in a Linked List

def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        t = node.next.next
        node.val = node.next.val
        node.next = t
        return

30 . Add two numbers as linked list

def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        r = 0
        cnt = 0
        head = ListNode()
        h = head        
        while l1 != None or l2 != None or r != 0:
            x1 = 0
            x2 = 0
            cnt = cnt+1
            if l1 != None:
                x1 = l1.val
                l1 = l1.next
                
            if l2 != None:
                x2 = l2.val
                l2 = l2.next
                
            head.val = r+x1+x2
            if head.val >= 10:
                head.val = head.val-10
                r = 1
                
            else:
                r = 0
            
            # print(head.val)
            if l1 == None and l2 == None and r == 0:
                head.next = None
                break
            
            e = ListNode()
            head.next = e
            head = head.next
        
        return h

31 . Intersection of Two Linked Lists

    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        #Optimal Solution 1
        h1 = headA
        h2 = headB
        cnt1 = 0
        cnt2 = 0
        while h1 != None:
            h1 = h1.next
            cnt1 += 1
            
        while h2 != None:
            h2 = h2.next
            cnt2 += 1
            
        h1 = headA
        h2 = headB
        cnt = abs(cnt1-cnt2)
        if cnt1 >= cnt2:
            e = 1
            while e <= cnt:
                h1 = h1.next
                e = e+1
            
        else:
            e = 1
            while e <= cnt:
                h2 = h2.next
                e = e+1
        
        f = 0
        while h1 != None and h2 != None:
            if h1 == h2:
                f = 1
                break
                
            h1 = h1.next
            h2 = h2.next
            
        if f:
            return h1
        
        else:
            return None

def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        #Optimal Solution 2
        if headA == None or headB == None:
            return None                        
        
        a = headA
        b = headB
        while a != b:            
            a = a.next
            b = b.next
            if a == None and b == None:
                break
            
            if a == None:   ==> Expalnation : Difference will be nullified in this assignment.
                a = headB
                
            if b == None:
                b = headA
                
        return a


32 . Linked List Cycle

def hasCycle(self, head: ListNode) -> bool:
        i = head
        j = head
        s = head
        f = 0
        g = 0
        while f == 0:
            if j == None or j.next == None:
                g = 1
                # f = 1
                break
            
            i = i.next
            j = j.next.next
            if i == j:
                f = 1
            
        if g:
            return False
        
        return True

33 . Reverse Nodes in k-Group

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if head == None or k == 1:
            return head
        
        node = head
        cnt = 0
        while node != None:             # Explanation : Count the number of total nodes and calculate 
            cnt += 1                      how much k-length lists are there.Make two variables first_element
            node = node.next              and current_head. if flag == 0 assign head to the last element of
                                          first k-length list. We have updated our list. Now we check 
                                          what is the last_element of previous list(first_element variable) and 
                                          we assign its next to our head which we got after doing reversal.  
        cnt = cnt//k
        first_element = None              
        current_head = head
        flag = 0
        while cnt > 0:
            count = 0
            node = current_head
            previous = None
            while count < k:
                ahead = node.next
                node.next = previous
                previous = node
                node = ahead
                count += 1
                
            if flag == 0:
                head = previous
                flag = 1
                
            if first_element != None:
                first_element.next = previous
                
            first_element = current_head
            current_head = node
                
            cnt -= 1
        
        if first_element != None:
            first_element.next = node
            
        return head
        
34 . Palindrome Linked List

def isPalindrome(self, head: ListNode) -> bool:
        if head == None:
            return True
        
        s = head
        f = head
        h = head
        g = 0
        while g == 0:
            if f.next == None:
                g = 1
                break
                
            if f.next.next == None:
                g = 1
                break
                
            f = f.next.next
            s = s.next
        
        prev = s
        s = s.next
        prev.next = None
        while s != None:
            t = s.next
            s.next = prev
            prev = s
            s = t
            
        p2 = prev
        p1 = h
        e1 = ListNode()
        e2 = ListNode()
        f = 1
        while (p1 != p2) and (p2 != e1) and (p1 != e2):
            if p1.val != p2.val:
                f = 0
                break
            
            e1 = p1
            e2 = p2
            p1 = p1.next
            p2 = p2.next
            
        if f:
            return True
        
        return False

35 . Linked List Cycle II

def detectCycle(self, head: ListNode) -> ListNode:
        i = head
        j = head
        s = head
        f = 0
        g = 0
        while f == 0:
            if j == None or j.next == None:
                g = 1
                # f = 1
                break
            
            i = i.next
            j = j.next.next
            if i == j:
                f = 1
            
        if g:
            return None
        
        c = i
        while c != s:
            c = c.next
            s = s.next
            
        return s

36 . Flattening a Linked List

Node *merge(Node *a,Node *b)
{
    Node *temp = new Node(0);
    Node *res = temp;
    while(a != NULL && b != NULL){
        if(a->data < b->data){
            temp->bottom = a;
            temp = temp->bottom;
            a = a->bottom;
        }
        else{
            temp->bottom = b;
            temp=temp->bottom;
            b = b->bottom;
        }
    }
    if(a){
        temp->bottom = a;
    }
    else{
        temp->bottom = b;
    }
    return res->bottom;
}
    

Node *flatten(Node *root)
{
   // Your code here
   if(root == NULL ||NULL){
       return root;
   }
   root->next = flatten(root->next);
   root = merge(root,root->next);
}

37 . Rotate List

def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if head == None:
            return None
        
        s = head
        f = head
        cnt = 0
        r = 0
        h = head
        while h != None:
            h = h.next
            r = r+1
        
        if r <= k:
            k = k%r
            
        if k == 0:
            return head
            
        while cnt < k:
            f = f.next
            cnt = cnt+1
            
        while f != None:
            prev1 = s
            s = s.next
            prev2 = f
            f = f.next
            
        top = head
        prev1.next = None
        head = s
        prev2.next = top
        return head        

38 . Copy List with Random Pointer

def copyRandomList(self, head: 'Node') -> 'Node':
        if head == None:
            return None
        
        h = head
        r = head
        while h != None:
            nh = Node(0)
            nh.val = h.val
            nh.next = h.next
            h.next = nh
            h = nh.next
            
        h = head
        while h != None:
            r = h.random
            n = h.next
            if r == None:
                n.random = None
            
            else:
                n.random = r.next
            
            h = h.next.next
            
        cnt = 0
        h = head
        while h != None:
            e1 = h.next
            e2 = h.next.next
            h.next = e2
            # e1 = e2.next
            if e2 == None:
                e1.next = None
                
            else:
                e1.next = e2.next
                
            if cnt == 0:
                newhead = e1
                cnt = 1
                
            h = e2
            
        return newhead

39 . 3sum

def threeSum(self, nums: List[int]) -> List[List[int]]:
        #Optimal approach
        nums.sort()
        prev = -10**9
        i = 0
        s = set()
        while i < len(nums):
            x = -1*nums[i]
            if x != prev:
                l = i+1
                r = len(nums)-1
                while l < r:
                    if nums[l]+nums[r] == x:
                        s.add((-1*x,nums[l],nums[r]))
                        l = l+1
                        r = r-1
                        continue
                        
                    if nums[l]+nums[r] > x:
                        r = r-1
                        
                    else:
                        l = l+1
            
            prev = nums[i]
            i = i+1
            
        l = list(s)
        return l

40 . Trapping Rain Water

def trap(self, height: List[int]) -> int:
        #Optimal Approach
        n = len(height)
        l = 0
        r = n-1
        lmax = 0
        rmax = 0
        ans = 0
        while l <= r:
            if height[l] <= height[r]:
                if height[l] < lmax:
                    ans += (lmax-height[l])

                else:
                    lmax = height[l]
                    
                l = l+1
                
            else:
                if height[r] < rmax:
                    ans += (rmax-height[r])
                    
                else:
                    rmax = height[r]
                    
                r = r-1
                
        return ans

41 . Remove Duplicates from Sorted Array

def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        j = 0
        A = nums
        while(i < len(A)):
            A[j] = A[i]
            while(i < len(A)-1 and A[i] == A[i+1]):
                i = i+1
                
            j = j+1
            i = i+1
        
        return j

42 . Max Consecutive Ones

def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        c = 0
        ans = 0
        for i in nums:
            if i == 0:
                ans = max(ans,c)
                c = 0
                
            else:
                c += 1
        
        ans = max(ans,c)
        return ans

43 . N meetings in one room

def maximumMeetings(n,start,end):
    # code here
    l = []
    for i in range(n):
        l.append((start[i],end[i]))
        
    l.sort(key=lambda x: x[1])
    ans = 1
    i = 0
    j = i+1
    # print(l)
    while i < n and j < n:
        if l[j][0] > l[i][1]:
            i = j
            j = i+1
            ans += 1
            
        else:
            j = j+1
            
    return ans

44 . Minimum Platforms

def minimumPlatform(n,arr,dep):
    '''
    :param n: number of activities
    :param arr: arrival time of trains
    :param dep: corresponding departure time of trains
    :return: Integer, minimum number of platforms needed
    '''
    # code here
    arr.sort()
    dep.sort()
    ans = 1
    cnt = 0
    i = 0
    j = 0
    a = len(arr)
    d = len(dep)
    while i < a and j < d:
        if arr[i] <= dep[j]:
            cnt += 1
            i = i+1
            
        else:
            cnt -= 1
            j = j+1
            
        ans = max(ans,cnt)
        
    return ans

45 . Job Sequencing Problem

def JobScheduling(self,Jobs,n):
        '''
        :param Jobs: list of "Job" class defined in driver code, with "profit" and "deadline".
        :param n: total number of jobs
        :return: A list of size 2 having list[0] = count of jobs and list[1] = max profit
        '''
        '''
        {
            class Job:.
            def __init__(self,profit=0,deadline=0):
                self.profit = profit
                self.deadline = deadline
                self.id = 0
        }
        '''
        # code here
        Jobs.sort(key=lambda x: x.profit,reverse = True)
        # print(Jobs[0].profit)
        visited = set()
        ans = 0
        profit = 0
        for i in Jobs:
            time = i.deadline
            cnt = i.profit
            while time > 0:
                if time not in visited and time <= n:
                    ans += 1
                    profit += cnt
                    visited.add(time)
                    break
                
                time -= 1
                
        return [ans,profit]

46 . Fractional Knapsack

def fractionalknapsack(self, W,Items,n):
        '''
        :param W: max weight which can be stored
        :param Items: List contianing Item class objects as defined in driver code, with value and weight
        :param n: size of Items
        :return: Float value of max possible value, two decimal place accuracy is expected by driver code
        
        {
            class Item:
            def __init__(self,val,w):
                self.value = val
                self.weight = w
        }
        '''
        # code here
        arr = []
        for i in Items:
            arr.append((i.value/i.weight,i.value,i.weight))
            
        arr.sort(reverse = True)
        ans = 0
        v = 0
        for i in arr:
            if v+i[2] <= W:
                ans += i[1]
                v += i[2]
                
            else:
                e = i[1]/i[2]
                ans += (e*(W-v))
                break
            
        return ans

47 . Combination Sum

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def rec(i,l,target):
            if i == len(candidates):
                return
            
            som = sum(l)+candidates[i]
            if som > target:
                return
            
            if som == target:
                ans.append(l+[candidates[i]])
                return
            
            j = i
            while(j < len(candidates)):
                rec(j,l+[candidates[i]],target)
                j = j+1
                
            return
        
        
        ans = []
        i = 0
        while(i < len(candidates)):
            rec(i,[],target)
            i = i+1
                
        return ans

48 . Combination Sum II

def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def rec(i,l,target):
            if i == len(candidates):
                return
            
            som = sum(l)+candidates[i]
            if som > target:
                return
            
            if som == target:
                ans.append(l+[candidates[i]])
                return
            
            j = i+1
            prev = -1
            while(j < len(candidates)):
                if candidates[j] == prev:
                    j = j+1
                    continue
                
                rec(j,l+[candidates[i]],target)
                prev = candidates[j]
                j = j+1
                
            return
        
        
        ans = []
        candidates.sort()
        i = 0
        prev = -1
        while(i < len(candidates)):
            if candidates[i] == prev:
                i = i+1
                continue
                
            rec(i,[],target)
            prev = candidates[i]
            i = i+1
                
        return ans

49 . Palindrome Partitioning

def partition(self, s: str) -> List[List[str]]:
        #Checks if a string is palindrome or not
        def ispal(start,end):
            i = start
            j = end
            f = 1
            while i < j:
                if s[i] != s[j]:
                    f = 0
                    break

                i += 1
                j -= 1

            return  f
        
        def rec(index,path):
            if index == len(s):
                ans.append(path)
                return
            
            else:
                for i in range(index,len(s)):
                    if ispal(index,i):
                        rec(i+1,path+[s[index:i+1]])
                        
                return
                
        ans = []
        path = []
        rec(0,path)
        return ans

50 . Subset Sums

class Solution:
	def subsetSums(self, arr, N):
		# code here
		def rec(index,som,N):
		    if index == N:
		        ans.append(som)
		        return
		    
		    else:
		        som += arr[index]
		        for i in range(index+1,N+1):
		            rec(i,som,N)
		            
		        return
		
		
		ans = []
		for i in range(N):
		    rec(i,0,N)
		
		ans.append(0)
		ans.sort()
		return ans
        
51 . Subset Sum-2

52 . K-th permutation Sequence

import math
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        l = [i for i in range(1,n+1)]
        ans = []
        k = k-1
        while True and len(l) != 0:
            x = math.factorial(len(l))//len(l)
            e = k//x
            h = l[e]
            ans.append(str(h))
            k = k%x
            o = []
            for i in l:
                if i != h:
                    o.append(i)
                    
            l = o
            
        return "".join(ans)

53. Permutations

class Solution:
    #Solution with set
    def rec(self,som,visited):
        if len(som) == len(self.nums):
            self.ans.append(som)
            return
        
        
        for i in self.nums:
            if i in visited:
                continue
            
            e = set()
            for j in visited:
                e.add(j)
                
            e.add(i)
            self.rec(som+[i],e)
            
        return
    
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.nums = nums
        self.ans = []
        visited = set()
        self.rec([],visited)
        return self.ans

#Space Optimized
class Solution:
    def rec(self,ptr,som):
        if ptr == len(som):
            self.ans.append(som)
            
        for i in range(ptr,len(self.nums)):
            o = []
            for j in som:
                o.append(j)
                
            o[ptr],o[i] = o[i],o[ptr]
            self.rec(ptr+1,o)
            
        return
    
    
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.nums = nums
        self.ans = []
        l = []
        for i in self.nums:
            l.append(i)
            
        self.rec(0,l)
        return self.ans    
    

54 . N queens Problem 

class Solution:
    def rec(self,col,mat):
        if col == self.n:
            o = []
            for i in mat:
                o.append("".join(i))
                
            self.ans.append(o)
            return
        
        for row in range(self.n):
            #Checking if the placing is valid or not
            flag = 0
            #Row wise
            for e in range(self.n):
                if mat[row][e] == "Q":
                    flag = 1
                    break
                    
            #Column wise
            for e in range(self.n):
                if mat[e][col] == "Q":
                    flag = 1
                    break
            
            #Diagonal wise
            r = row
            c = col
            while r > -1 and c > -1:
                if mat[r][c] == "Q":
                    flag = 1
                    break
                    
                r -= 1
                c -= 1
                
            r = row
            c = col
            while r < self.n and c < self.n:
                if mat[r][c] == "Q":
                    flag = 1
                    break
                    
                r += 1
                c += 1
                
            r = row
            c = col
            while r > -1 and c < self.n:
                if mat[r][c] == "Q":
                    flag = 1
                    break
                    
                r -= 1
                c += 1
                
            r = row
            c = col
            while r < self.n and c > -1:
                if mat[r][c] == "Q":
                    flag = 1
                    break
                    
                r += 1
                c -= 1
                
            if flag:
                continue
                
            tmat = []
            for h1 in mat:
                w = []
                for h2 in h1:
                    w.append(h2)
                    
                tmat.append(w)
                
            tmat[row][col] = "Q"
            self.rec(col+1,tmat)
            
        return
                
    def solveNQueens(self, n: int) -> List[List[str]]:
        self.n = n
        self.ans = []
        mat = []
        for i in range(n):
            o = []
            for j in range(n):
                o.append(".")
                
            mat.append(o)
        
        self.rec(0,mat)
        return self.ans

55 . Sudoko

class Solution:
    def solve(self):
        for i in range(9):
            for j in range(9):
                if self.board[i][j] == ".":
                    for k in range(1,10):
                        if self.isValid(i,j,str(k)) == True:
                            self.board[i][j] = str(k)
                            if self.solve() == True:
                                return True
                            
                            else:
                                self.board[i][j] = "."
                        
                    return False
                
        return True
    
    def isValid(self,row,col,c):
        for i in range(9):
            if self.board[i][col] == c:
                return False
            
            if self.board[row][i] == c:
                return False
            
            if self.board[(3*(row//3))+(i//3)][(3*(col//3))+(i%3)] == c:
                return False
            
        return True
    
    
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.board = board
        self.solve()
        return
 
56 . M coloring Problem (Graph prob) 

#Function to determine if graph can be coloured with at most M colours such
#that no two adjacent vertices of graph are coloured with same colour.
def isValid(node,graph,color,r):
    for i in range(len(graph[0])):
        if graph[node][i]:
            if color[i] == r:
                return False
                
    return True
    

def solve(node,graph,k,V,color):
    if node == V:
        return True
        
    for c in range(1,k+1):
        if isValid(node,graph,color,c):
            color[node] = c
            if solve(node+1,graph,k,V,color):
                return True
                
            else:
                color[node] = 0
        
    return False

def graphColoring(graph, k, V):
    #your code here
    color = [0 for i in range(V)]
    if solve(0,graph,k,V,color):
        return True
        
    return False


57 . Rat in a Maze 

import sys
sys.setrecursionlimit(10**6)
class Solution:
    def findPath(self, m, n):
        # code here
        def solve(i,j,path,n,m,di,dj):
            if i == n-1 and j == n-1:
                ans.append(path)
                return
                
            else:
                direction = "DLRU"
                for ind in range(4):
                    nexti = i+di[ind]
                    nextj = j+dj[ind]
                    if nexti < 0 or nexti >= n or nextj < 0 or nextj >= n:
                        continue
                    
                    if m[nexti][nextj] == 1:
                        m[i][j] = 0
                        solve(nexti,nextj,path+direction[ind],n,m,di,dj)
                        m[i][j] = 1
                
                return
        
        ans = []
        di = [1,0,0,-1]
        dj = [0,-1,1,0]
        if m[0][0]:
            solve(0,0,"",n,m,di,dj)
        
        return ans


58 . Word Break (print all ways)

59 .  1/N-th root of an integer (use binary search) (square root, cube root, ..)

def findRoot(x,n):
    low = 0
    high = x
    cnt = 0
    while low < high and cnt < 200:
        mid = low+((high-low)/2)
        if mid**n > x:
            high = mid

        else:
            low = mid

        cnt = cnt+1

    return low

####################################################
class Solution:
    # @param A : integer
    # @param B : integer
    # @param C : list of integers
    # @return an integer
    def paint(self, A, B, C):
        #Painter's Partition (Binary Search Approach)
        def check(mid):
            som = 0
            painter = 1
            for i in C:
                if i > mid:
                    painter = 10000
                    break
                
                som = som+i
                if som > mid:
                    som = i
                    painter += 1
                
                
            return painter
            
        
        M = 10000003
        high = sum(C)
        low = 1
        ans = high
        while low <= high:
            mid = low+((high-low)//2)
            check(mid)
            if check(mid) <= A:
                ans = mid
                high = mid-1
                
            else:
                low = mid+1
                
        return (ans*B)%M

#########################################################


60 . Median in a row-wise sorted Matrix

from bisect import bisect_right

class Solution:
    def median(self, matrix, r, c):
    	#code here 
    	mi = 10**18
    	ma = 0
    	for i in range(r):
    	    mi = min(mi,matrix[i][0])
    	    ma = max(ma,matrix[i][-1])
    	    
    	desired = (r*c+1)//2
    	while mi < ma:
    	    mid = mi+((ma-mi)//2)
    	    place = 0
    	    for i in range(r):
    	        j = bisect_right(matrix[i],mid)
    	        place += j
    	        
    	    if place < desired:
    	        mi = mid+1
    	        
    	    else:
    	        ma = mid
    	        
    	return mi

61 . Single Element in a Sorted Array

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        ma = len(nums)-1
        mi = 0
        while mi < ma:
            mid = (mi+ma)//2
            flag = 0
            if mid != mi:
                if nums[mid] == nums[mid-1]:
                    res = mid-1
                    flag = 1
                    
                    
            if mid != ma:
                if nums[mid] == nums[mid+1]:
                    res = mid
                    flag = 1
                    
            if not flag:
                return nums[mid]
            
            else:
                diff = ma-res+1
                if diff%2 == 0:
                    ma = res-1
                    
                else:
                    mi = res+2
                    
        return nums[(mi+ma)//2]

62 . Search in Rotated Sorted Array

from bisect import bisect
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums)-1
        while low < high:
            mid = (low+high)//2
            if nums[mid] > nums[high]:
                low = mid+1
                
            else:
                high = mid
        
        if high > 0:
            x = bisect(nums,target,0,high)
            if x > 0:
                if nums[x-1] == target:
                    return x-1
        
        if high < len(nums):
            x = bisect(nums,target,high,len(nums))
            if nums[x-1] == target:
                return x-1
        
        return -1

63 . Median of Two Sorted Arrays

class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1,nums2 = nums2,nums1
            
        x = len(nums1)
        y = len(nums2)
        low = 0
        high = x
        while low <= high:
            partitionX = (low+high)//2
            partitionY = ((x+y+1)//2)-partitionX
            if partitionX == 0:
                maxLeftX = -1*(10**18)
                
            else:
                maxLeftX = nums1[partitionX-1]
            
            if partitionX == x:
                minRightX = 1*(10**18)
                
            else:
                minRightX = nums1[partitionX]
                
            if partitionY == 0:
                maxLeftY = -1*(10**18)
                
            else:
                maxLeftY = nums2[partitionY-1]
            
            if partitionY == y:
                minRightY = 1*(10**18)
                
            else:
                minRightY = nums2[partitionY]
                
            if maxLeftX <= minRightY and maxLeftY <= minRightX:
                if (x+y)%2 == 0:
                    return (max(maxLeftX,maxLeftY)+min(minRightY,minRightX))/2
                
                else:
                    return max(maxLeftX,maxLeftY)
                
            elif maxLeftX > minRightY:
                high = partitionX-1
                
            else:
                low = partitionX+1

64 . K-th element of two sorted Arrays

class Solution:
    def kthElement(self,  arr1, arr2, n, m, k):
        low = 0
        high = max(arr1[-1],arr2[-1])
        while low < high:
            mid = (low+high)//2
            cnt = 0
            for x in arr1:
                if x <= mid:
                    cnt += 1
                    
            for x in arr2:
                if x <= mid:
                    cnt += 1
            
            
            if cnt < k:
                low = mid+1
                
            else:
                high = mid
                
        return high

65 . Check if a number if a power of 2 or not in O(1) 

class Solution:
    ##Complete this function
    # Function to check if given number n is a power of two.
    def isPowerofTwo(self,n):
        ##Your code here
        s = bin(n)[2:]
        if s.count("1") == 1:
            return True
            
        return False

66 . Count total set bits

class Solution:
	def setBits(self, N):
		# code here
		s = bin(N)[2:]
		return s.count("1")

67 . Divide Integers without / operator 

class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        cnt = 0
        if dividend < 0:
            dividend = -1*dividend
            cnt += 1
            
        if divisor < 0:
            divisor = -1*divisor
            cnt += 1
        
        ans = 0
        while True:
            if dividend < divisor:
                break
                
            else:
                power = 33
                while (2**power)*divisor > dividend:
                    power -= 1
                    
                ans += 2**power
                dividend -= (2**power)*divisor
                
        if cnt%2:
            ans = -1*ans
        
        if ans >= 2**31:
            return (2**31)-1
        
        return ans

67 . Power Set 

class Solution:
	def AllPossibleStrings(self, s):
		# Code here
		ans = []
		m = len(s)
		for i in range(1,2**m):
		    x = bin(i)[2:]
		    rem = m-len(x)
		    x = (rem*"0")+x
		    c = ""
		    for j in range(m):
		        if x[j] == "1":
		            c  = c+s[j]
		            
		    ans.append(c)
		
		ans.sort()    
		return ans

68 . Find square of a number without using multiplication or division operators. 


##########################################################
square(n) = 0 if n == 0
  if n is even 
     square(n) = 4*square(n/2) 
  if n is odd
     square(n) = 4*square(floor(n/2)) + 4*floor(n/2) + 1 

Examples
  square(6) = 4*square(3)
  square(3) = 4*(square(1)) + 4*1 + 1 = 9
  square(7) = 4*square(3) + 4*3 + 1 = 4*9 + 4*3 + 1 = 49
How does this work? 

If n is even, it can be written as
  n = 2*x 
  n2 = (2*x)2 = 4*x2
If n is odd, it can be written as 
  n = 2*x + 1
  n2 = (2*x + 1)2 = 4*x2 + 4*x + 1

#########################################################

# Square of a number using bitwise
# operators


def square(n):

	# Base case
	if (n == 0):
		return 0

	# Handle negative number
	if (n < 0):
		n = -n

	# Get floor(n/2) using
	# right shift
	x = n >> 1

	# If n is odd
	if (n & 1):
		return ((square(x) << 2)
				+ (x << 2) + 1)

	# If n is even
	else:
		return (square(x) << 2)


69 . Implement Stack / Implement Queue

#Implement Queue
def enque(val,n):
    global p2
    if queue[(p2+1)%n] != -1:
        print("Queue Full")
        return

    p2 = (p2+1)%n
    queue[p2] = val
    return

def deque():
    global p1
    if p1 == p2:
        print("Queue is empty !")
        return 0

    p1 = (p1+1)%n
    val = queue[p1]
    queue[p1] = -1
    return val

p1 = -1
p2 = -1
n = int(input())
queue = [-1]*n
while True:
    print(queue)
    x = int(input())
    if x == -1:
        break

    if x == 0:
        print(deque())
        continue

    enque(x,n)

70 . BFS

from collections import deque
def bfs(start,graph):
    visited = {start}
    explored = set()
    levels = {start : 0}
    queue = deque([])
    queue.append(start)
    while len(queue) > 0:
        x = queue.popleft()
        explored.add(x)
        if x not in graph:
            continue

        for i in graph[x]:
            if i not in visited:
                visited.add(i)
                queue.append(i)
                levels[i] = levels[x]+1

    return levels

71 . Implement Stack using Queues

from collections import deque
#Push Costly

class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        
        self.q1 = deque([])
        self.q2 = deque([])
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.q2.append(x)
        while len(self.q1) > 0:
            self.q2.append(self.q1.popleft())
            
        while len(self.q2) > 0:
            self.q1.append(self.q2.popleft())
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
            
        if len(self.q1) == 0:
            return None
        
        return self.q1.popleft()
        

    def top(self) -> int:
        """
        Get the top element.
        """
        
        
        if len(self.q1) == 0:
            return None
        

        return self.q1[0]
        

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        
        if len(self.q1) == 0:
            return True
        
        return False
        
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

from collections import deque
#Pop Costly

class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        
        self.q1 = deque([])
        self.q2 = deque([])
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """

        self.q1.append(x)


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
            
        if len(self.q1) == 0:
            return None
        
        val = 0
        while len(self.q1) > 0:
            val = self.q1[0]
            if len(self.q1) == 1:
                self.q1.popleft()
                continue
            
            self.q2.append(self.q1.popleft())
            
        while len(self.q2) > 0:
            self.q1.append(self.q2.popleft())
            
            
        return val

    def top(self) -> int:
        """
        Get the top element.
        """
        if len(self.q1) == 0:
            return None
        
        val = 0
        while len(self.q1) > 0:
            val = self.q1[0]
            self.q2.append(self.q1.popleft())
            
        while len(self.q2) > 0:
            self.q1.append(self.q2.popleft())
            
            
        return val
        

        # return self.q1[0]
        

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        
        if len(self.q1) == 0:
            return True
        
        return False
        
        


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

72 . Implement Queue using Stacks

class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []
        

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.s1.append(x)
        

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        while len(self.s1) > 0:
            self.s2.append(self.s1.pop())
            
        val = self.s2.pop()
        while len(self.s2) > 0:
            self.s1.append(self.s2.pop())
        
        return val

    def peek(self) -> int:
        """
        Get the front element.
        """
        while len(self.s1) > 0:
            self.s2.append(self.s1.pop())
            
        val = self.s2[-1]
        while len(self.s2) > 0:
            self.s1.append(self.s2.pop())
        
        return val
        

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        if len(self.s1) == 0:
            return True
        
        return False
        


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()

73 . Next Greater Element

class Solution:
    
    #Function to find the next greater element for each element of the array.
    def nextLargerElement(self,arr,n):
        #code here
        stack = []
        ans = [0]*n
        for i in range(n):
            if len(stack) == 0:
                stack.append(i)
                continue
          
            if arr[i] > arr[stack[-1]]:
                while len(stack) > 0:
                    if arr[i] <= arr[stack[-1]]:
                        break
                        
                    x = stack.pop()
                    ans[x] = arr[i]
                    

            stack.append(i)
                
        while len(stack) > 0:
            x = stack.pop()
            ans[x] = -1
            
        return ans
                

74 . LRUCache

class LRUCache:
    def __init__(self, capacity: int):
        self.hash = {}
        self.cache = {}
        self.hkey = -1
        self.lkey = -1
        self.capacity = capacity
        

    def get(self, key: int) -> int:
        if key in self.hash:            
            pr = self.cache[key][0]
            if pr == -1:
                return self.hash[key]
            
            ne = self.cache[key][1]
            if ne == -1:
                self.lkey = pr
                
            else:
                self.cache[ne][0] = pr
                
            self.cache[pr][1] = ne
            self.cache[key] = [-1,self.hkey]
            self.cache[self.hkey][0] = key
            self.hkey = key
            return self.hash[key]
        
        return -1
        

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.hash[key] = value
            pr = self.cache[key][0]
            if pr != -1:
                ne = self.cache[key][1]
                if ne == -1:
                    self.lkey = pr
                    self.cache[pr][1] = -1
                
                else:
                    self.cache[pr][1] = ne
                    self.cache[ne][0] = pr
                
                self.cache[key] = [-1,self.hkey]
                self.cache[self.hkey][0] = key
                self.hkey = key
            
        else:
            val = value
            if len(self.cache) == 0:
                self.cache[key] = [-1,-1]
                self.hkey = key
                self.lkey = key
                self.hash[key] = val
                
            else:
                if len(self.cache)+1 > self.capacity:
                    pr = self.cache[self.lkey][0]
                    if pr == -1:
                        del self.cache[self.lkey]
                        del self.hash[self.lkey]
                        self.lkey = -1
                        self.hkey = -1
                        
                    
                    else:
                        self.cache[pr][1] = -1
                        del self.cache[self.lkey]
                        del self.hash[self.lkey]
                        self.lkey = pr
                
                if len(self.cache) == 0:
                    self.cache[key] = [-1,-1]
                    self.hkey = key
                    self.lkey = key
                    self.hash[key] = val
                
                else:
                    self.cache[key] = [-1,-1]
                    self.cache[key] = [-1,self.hkey]
                    self.cache[self.hkey][0] = key
                    self.hkey = key
                    self.hash[key] = val

75 . Largest rectangle in histogram 

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        n = len(heights)
        ans = 0
        heights.append(0)
        for i in range(n+1):
            if len(stack) == 0:
                ans = max(heights[i],ans)
                stack.append(i)
                continue
                
            if heights[i] >= heights[stack[-1]]:
                stack.append(i)
                continue
                
            while len(stack) > 0:
                if heights[stack[-1]] > heights[i]:
                    x = stack.pop()
                    if len(stack) == 0:
                        ans = max(ans,heights[x]*i)
                        
                    else:
                        ans = max(ans,heights[x]*(i-stack[-1]-1))
                        
                    continue
                    
                break
                
            stack.append(i)
                    
        return ans
        


76 . Sliding Window maximum

#Nlogn Solution
import heapq
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        i = 0
        # l = nums
        d = {}
        c = {}
        ans = []
        ma = -1*(10**18)
        h = []
        heapq.heapify(h)
        while i < k:
            x = nums[i]
            heapq.heappush(h,-1*x)
            if x in d:
                d[x] += 1
                # c[x] += 1
                
            else:
                d[x] = 1
                # c[x] = 1
            
            ma = max(ma,x)
            i = i+1
            
        ans.append(ma)
        p1 = 0
        p2 = i
        while p2 < len(nums):
            # print(h)
            x1 = nums[p1]
            x2 = nums[p2]
            d[x1] -= 1
            if x2 in d:
                d[x2] += 1
                
            else:
                d[x2] = 1
                
            heapq.heappush(h,-1*x2)
            if x2 >= ma:
                ma = x2
                ans.append(ma)
            
            else:
                if d[ma] == 0:
                    while True:
                        # print(h)
                        ma = -1*heapq.heappop(h)
                        if d[ma] > 0:
                            heapq.heappush(h,-1*ma)
                            break
                                
                    
                    ans.append(ma)
                    
                else:
                    ans.append(ma)
            
            p1 += 1
            p2 += 1
            
        return ans
        
# Monotonic Queue Approach
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        queue = deque([])
        ans = []
        l = 0
        for r in range(len(nums)):
            while len(queue) > 0:
                if nums[queue[-1]] < nums[r]:
                    queue.pop()
                    
                else:
                    break
                    
            queue.append(r)
            if l > queue[0]:
                queue.popleft()
                
            if r+1 >= k:
                ans.append(nums[queue[0]])
                l += 1 
            
        return ans
    
77 . Implement MinStack

#Two stack space optimized solution
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.cache = []
        

    def push(self, val: int) -> None:
        if len(self.stack) == 0:
            self.stack.append(val)
            self.cache.append([val,1])
            
        else:
            if val > self.cache[-1][0]:
                self.stack.append(val)
                
            else:
                if val == self.stack[-1]:
                    x = self.cache[-1][1]
                    self.cache[-1][1] = x+1
                    
                else:
                    self.cache.append([val,1])
                    
                self.stack.append(val)                
                    

    def pop(self) -> None:
        if self.stack[-1] == self.cache[-1][0]:
            self.stack.pop()
            x = self.cache[-1][1] -1
            if x == 0:
                self.cache.pop()
            
            else:
                self.cache[-1][1] = x
        
        else:
            self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]
        

    def getMin(self) -> int:
        # print(self.stack)
        # print(self.cache)
        return self.cache[-1][0]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

78 . Rotten Orange

from collections import deque
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        def bfs(graph,cnt,visited,queue,levels):
            explored = set()
            while queue:
                node = queue.popleft()
                explored.add(node)
                if node not in graph:
                    continue
                
                neighbours = graph[node]
                for neighbour in neighbours:
                    if neighbour not in visited:
                        queue.append(neighbour)
                        visited.add(neighbour)
                        levels[neighbour]= levels[node]+1
                    
            
            if cnt != len(explored):
                return -1
            
            ans = 0
            for i in levels:
                ans = max(levels[i],ans)
            
            return ans
        
        graph = {}
        cnt = 0
        queue = deque([])
        visited = set()
        levels = {}
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] != 0:
                    cnt += 1
                    l = [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]
                    for k in l:
                        if k[0] > -1 and k[0] < len(grid) and k[1] > -1 and k[1] < len(grid[0]):
                            if grid[k[0]][k[1]] != 0:
                                if (i,j) in graph:
                                    graph[(i,j)].append(k)
                                    
                                else:
                                    graph[(i,j)] = [k]
                                    
                if grid[i][j] == 2:
                    queue.append((i,j))
                    visited.add((i,j))
                    levels[(i,j)] = 0
        
        # print(cnt)
        return bfs(graph,cnt,visited,queue,levels)

79 . Reverse Words in a String

class Solution:
    def reverseWords(self, s: str) -> str:
        l = []
        w = ""
        flag = 0
        for i in s:
            if i == " ":
                if flag:
                    l.append(w)
                    flag = 0
                    w = ""
                
                continue
            
            w += i
            flag = 1
            
        if flag:
            l.append(w)
            
        i = 0
        j = len(l)-1
        while i < j:
            l[i],l[j] = l[j],l[i]
            i += 1
            j -= 1
            
        return " ".join(l)

80 . Longest Palindromic Substring

class Solution:
    def longestPalindrome(self, s: str) -> str:
        ai = -1
        aj = -1
        ans = 0
        n = len(s)
        for i in range(n):
            e1 = i
            e2 = i
            cnt = 0
            while e1 > -1 and e2 < n:
                if s[e1] == s[e2]:
                    if e1 == e2:
                        cnt += 1
                        
                    else:
                        cnt += 2
                        
            
                    
                    e1 -= 1
                    e2 += 1
                    continue
                
                break
                
            if cnt > ans:
                ans = cnt
                ai = e1+1
                aj = e2-1
                
            e1 = i
            e2 = i+1
            cnt = 0
            while e1 > -1 and e2 < n:
                if s[e1] == s[e2]:
                    if e1 == e2:
                        cnt += 1
                        
                    else:
                        cnt += 2
                        
                    e1 -= 1
                    e2 += 1
                    continue
                
                break
                
            if cnt > ans:
                ans = cnt
                ai = e1+1
                aj = e2-1
                
        p = []
        for i in range(ai,aj+1):
            p.append(s[i])
            
        return "".join(p)

81 . #Roman to integer

class Solution:
    def romanToInt(self, s: str) -> int:
        d = {"I" : 1,"V" : 5,"X" : 10,"L" : 50,"C":100,"D":500,"M":1000}
        ans = 0
        cur = 0
        s = s[::-1]
        for i in s:
            if d[i] >= cur:
                cur = d[i]
                ans += d[i]
                
            else:
                ans -= d[i]
                
        return ans
        
        
# Integer to Roman
class Solution:
    def intToRoman(self, num: int) -> str:
        d = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}
        l = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        ans = []
        x = num
        i = 0
        while x > 0:
            if x >= l[i]:
                x -= l[i]
                ans.append(d[l[i]])
                 
                
            else:
                i += 1
                
            # print(ans)
                
        return "".join(ans)

82 . Implement ATOI/STRSTR 

#Atoi

class Solution:
    def myAtoi(self, s: str) -> int:
        n = len(s)
        i = 0
        while i < n:
            x = s[i]
            if x == " ":
                i += 1
                continue
                
            break
            
        mul = 1
        if i >= n:
            return 0
            
        if s[i] == "+":
            i = i+1
        
        else:
            if s[i] == "-":
                mul -= 2
                i = i+1
        
        ans = 0
        while i < n:
            x = s[i]
            if x < '0' or x > '9':
                break
                
            
            ans = (10*ans)+(ord(x)-ord('0'))
            if ((ans//10 > (2**31)//10) or (ans//10 == ((2**31)//10) and x > '8')) and mul == -1:
                ans = 2**31
                i = i+1
                continue
                    
            if ((ans//10 > ((2**31)-1)//10) or (ans//10 == (((2**31)-1)//10) and x > '7')) and mul == 1:
                ans = (2**31)-1
                i = i+1
                continue
                    
            i = i+1
                
            
        return ans*mul
                
#STRSTR            

#Z Function
class Solution:
    def z_function(self,needle,haystack):
        #Creating the Z array
        s = needle+"$"+haystack
        n = len(s)
        z = [0]*n
        required = len(needle) #Length of the needle
        l = 0 #L and R are bounds for which we can use the pre computed values
        r = 0
        i = 1
        while i < n:
            if i >= l and i <= r:
                z[i] = min(r-i+1,z[i-l])
            
            while (i+z[i] < n) and (s[z[i]] == s[z[i]+i]):
                z[i] += 1
                
            if i+z[i]-1 > r:
                l = i
                r = i+z[i]-1
            
            i = i+1
            
        return z
    
    def strStr(self, haystack: str, needle: str) -> int:
        #New String
        if needle == "":
            return 0
        
        n = len(haystack)+len(needle)+1
        required = len(needle) #Length of the needle
        z = self.z_function(needle,haystack)
        ans = -1
        for i in range(required+1,n):
            if z[i] == required:
                ans = i-(required+1)
                break
                
        return ans



83 . Longest Common Prefix

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        ans = list(strs[0])
        for i in range(1,len(strs)):
            cur = []
            x = strs[i]
            for j in range(min(len(x),len(ans))):
                if ans[j] == x[j]:
                    cur.append(ans[j])
                    continue
                    
                break
                
            ans = cur
            
        return "".join(ans)
        
84 . Rabin Karp

#Rabin-Karp
    def calculate_hash(self,needle):
        M = (10**9)+7
        p = 101
        cur = 1
        ans = 0
        for i in range(len(needle)):
            x = ord(needle[i])-ord("a")+1
            x = (x*cur)%M
            cur = (cur*p)%M
            ans = (ans+x)%M
            
        return ans
            
    
    def rabin_karp(self,needle,haystack):
        needle_val = self.calculate_hash(needle)
        dp = []
        w = []
        p = 101
        M = (10**9)+7
        cur = 1
        ans = 0
        for i in range(len(haystack)):
            x = ord(haystack[i])-ord("a")+1
            x = (x*cur)%M
            w.append(cur)
            cur = (cur*p)%M
            ans = (ans+x)%M
            dp.append(ans)
        
        # print(dp)
        res = -1
        l = 0
        r = len(needle)-1
        # print(needle_val)
        while r < len(haystack):
            if l == 0:
                if dp[r] == needle_val:
                    return l
                
            else:
                # print(l,w[l])
                calc = (dp[r]-dp[l-1])%M
                if calc == (needle_val*w[l])%M:
                    return l
            
            l = l+1
            r = r+1
            
        return res

85 . Prefix Function/Z-Function

def z_function(self,needle,haystack):
        #Creating the Z array
        s = needle+"$"+haystack
        n = len(s)
        z = [0]*n
        required = len(needle) #Length of the needle
        l = 0 #L and R are bounds for which we can use the pre computed values
        r = 0
        i = 1
        while i < n:
            if i >= l and i <= r:
                z[i] = min(r-i+1,z[i-l])
            
            while (i+z[i] < n) and (s[z[i]] == s[z[i]+i]):
                z[i] += 1
                
            if i+z[i]-1 > r:
                l = i
                r = i+z[i]-1
            
            i = i+1
            
        return z

86 . KMP algo

 
87 . Minimum characters needed to be inserted in the beginning to make it palindromic. 
88 . Check for Anagrams 
89 . Count and Say 
90 . Compare version numbers 

91 . Inorder Traversal (with recursion and without recursion)

#Recursive code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def rec(node,ans):
            if node == None:
                return
            
            rec(node.left,ans)
            ans.append(node.val)
            rec(node.right,ans)
            return
            
        ans = []
        rec(root,ans)
        return ans

#Non Recursive code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []
        stack = [root]
        x = root
        while len(stack) > 0:
            if x == None:
                stack.pop()
                if len(stack) == 0:
                    break
                    
                e = stack.pop()
                ans.append(e.val)
                stack.append(e.right)
                x = e.right
                
            else:
                stack.append(x.left)
                x = x.left
            
        return ans

92 . Preorder Traversal (with recursion and without recursion) 

#Recursive Code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def rec(node,ans):
            if node == None:
                return
            
            ans.append(node.val)
            rec(node.left,ans)
            rec(node.right,ans)
            return
            
        ans = []
        rec(root,ans)
        return ans
 
#Non Recursive Code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        stack = [root]
        ans = []
        x = root
        while len(stack) > 0:
            if x == None:
                stack.pop()
                if len(stack) == 0:
                    break
                    
                e = stack.pop()
                x = e.right
                stack.append(x)
                
            else:
                ans.append(x.val)
                stack.append(x.left)
                x = x.left
                
        return ans

93 . Postorder Traversal (with recursion and without recursion) 

# Recursive

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def rec(node,ans):
            if node == None:
                return
            
            rec(node.left,ans)
            rec(node.right,ans)
            ans.append(node.val)
            # rec(node.right,ans)
            return
            
        ans = []
        rec(root,ans)
        return ans

#Non Recursive Code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        stack = [root]
        x = root
        ans = []
        while len(stack) > 0:
            if x == None:
                stack.pop()
                if len(stack) == 0:
                    break
                
                e = stack[-1]
                if e.right == None:
                    stack.pop()
                    ans.append(e)
                    if len(stack) == 0:
                        break
                        
                    x = stack[-1]
                    
                else:
                    if len(ans) > 0:
                        if ans[-1] == e.right:
                            stack.pop()
                            ans.append(e)
                            
                        else:
                            x = e.right
                            stack.append(x)
                        
                    else:
                        x = e.right
                        stack.append(x)
            
            else:
                if len(ans) > 0:
                    if ans[-1] == x.right:
                        ans.append(x)
                        stack.pop()
                        if len(stack) > 0:
                            x = stack[-1]
                            
                        else:
                            break
                            
                        continue
                        
                    if ans[-1] == x.left:
                        if x.right == None:
                            ans.append(x)
                            stack.pop()
                            if len(stack) > 0:
                                x = stack[-1]
                                
                            else:
                                break
                            
                            continue
                            
                        x = x.right
                        stack.append(x)
                        continue
                        
                
                x = x.left
                stack.append(x)
        
        r = []
        for i in ans:
            r.append(i.val)
        
        return r
        

94 . Binary Tree Right Side View

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        def rec(node,cnt,level):
            if node == None:
                return
            
            if cnt not in level:
                level[cnt] = node.val
                
            rec(node.right,cnt+1,level)
            rec(node.left,cnt+1,level)
            return
        
        if root == None:
            return []
        
        level = {}
        rec(root,0,level)
        # print(level)
        ma = 0
        for i in level:
            ma = max(ma,i)
        
        ans = [0]*(ma+1)
        for i in range(len(ans)):
            ans[i] = level[i]
            
        return ans

95 . Bottom View of Binary Tree

def bottomView(root):
    # code here
    def rec(node,dist,cnt,level):
        if node == None:
            return
        
        if dist in level:
            x = level[dist]
            if x[0] <= cnt:
                level[dist] = (cnt,node.data)
                    
        else:
            level[dist] = (cnt,node.data)
        
        rec(node.left,dist-1,cnt+1,level)
        rec(node.right,dist+1,cnt+1,level)
        return
    
    level = {}
    rec(root,0,0,level)
    # print(level)
    ans = []
    for i in level:
        ans.append((i,level[i][1]))
        
    ans.sort()
    l = []
    for i in ans:
        l.append(i[1])
        
    return l
            
96 . Top View of Binary Tree 

class Solution:
    
    #Function to return a list of nodes visible from the top view 
    #from left to right in Binary Tree.
    def topView(self,root):
        # code here
        def rec(node,dist,cnt,level):
            if node == None:
                return
        
            if dist in level:
                x = level[dist]
                if x[0] >= cnt:
                    level[dist] = (cnt,node.data)
                    
            else:
                level[dist] = (cnt,node.data)
                
            rec(node.right,dist+1,cnt+1,level)
            rec(node.left,dist-1,cnt+1,level)
            return
    
        level = {}
        rec(root,0,0,level)
        # print(level)
        ans = []
        for i in level:
            ans.append((i,level[i][1]))
        
        ans.sort()
        l = []
        for i in ans:
            l.append(i[1])
        
        return l

97 . Level order Traversal / Level order traversal in spiral form 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if root == None:
            return []
        
        stack1 = [root]
        stack2 = []
        ans = []
        while len(stack1) > 0 or len(stack2) > 0:
            # print(stack1)
            # print(stack2)
            o = []
            while len(stack1) > 0:
                x = stack1.pop()
                if x.left != None:
                    stack2.append(x.left)
                    
                if x.right != None:
                    stack2.append(x.right)
                    
                o.append(x.val)
                
            if len(o) > 0:
                ans.append(o)
                continue
                
            while len(stack2) > 0:
                x = stack2.pop()
                if x.right != None:
                    stack1.append(x.right)
                    
                if x.left != None:
                    stack1.append(x.left)
                
                o.append(x.val)
                
            ans.append(o)
            
        return ans
        
        
98 . Height of a Binary Tree 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        def rec(node,cnt):
            if node == None:
                return
            
            cnt += 1
            if cnt > ans[0]:
                ans[0] = cnt
                
            rec(node.left,cnt)
            rec(node.right,cnt)
            return
        
        ans = [0]
        rec(root,0)
        return ans[0]

99 . Diameter of Binary Tree 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def rec(node):
            if node == None:
                return 0
            
            cnt = 1
            e1 = rec(node.left)
            e2 = rec(node.right)
            o = cnt+e1+e2
            if o > ans[0]:
                ans[0] = o
                
            return max(e1,e2)+cnt            
        
        ans = [0]
        rec(root)
        return ans[0]-1

100 . Check if Binary tree is height balanced or not 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def rec(node):
            if node == None:
                return 0
            
            e1 = rec(node.left)
            e2 = rec(node.right)
            if abs(e2-e1) > 1:
                ans[0] = False
                
            return max(e1,e2)+1
        
        ans = [True]
        rec(root)
        return ans[0]

101 . LCA in Binary Tree
        
def rec(node):
            if node == None:
                return None
            
            if node == p or node == q:
                return node
            
            e1 = rec(node.left)
            e2 = rec(node.right)
            if e1 == None and e2 == None:
                return None
            
            if e1 != None and e2 != None:
                return node
            
            if e1 == None:
                return e2
            
            return e1
        
        return rec(root)

102 . Check if two trees are identical or not

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        def rec(node1,node2):
            if node1 == None and node2 == None:
                return
            
            if node1 == None and node2 != None:
                ans[0] = False
                return
                
            if node1 != None and node2 == None:
                ans[0] = False
                return
                
            if node1.val != node2.val:
                ans[0] = False
                return
            
            rec(node1.left,node2.left)
            rec(node1.right,node2.right)
            return
        
        ans = [True]
        rec(p,q)
        return ans[0]
        
103 . Binary Tree Maximum Path Sum

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        def rec(node):
            if node == None:
                return 0
            
            val = node.val
            e1 = rec(node.left)
            e2 = rec(node.right)
            a1 = e1+e2+val
            r = ans[0]
            z = max(e1+val,e2+val,a1,val)
            ans[0] = max(r,z)
            return max(e1+val,e2+val,val,0)
        
        ans = [-1*(10**18)]
        rec(root)
        return ans[0]
        
104 . Construct Binary Tree from inorder and preorder

105 . Construct Binary Tree from Inorder and Postorder

106 . Symmetric Binary Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rec(self,node1,node2):
        if (node1 == None and node2 != None) or (node1 != None and node2 == None):
            return 0
        
        if node1 == None and node2 == None:
            return 1
        
        if node1.val != node2.val:
            return 0
        
        return self.rec(node1.left,node2.right)&self.rec(node1.right,node2.left)
    
    
    def isSymmetric(self, root: TreeNode) -> bool:
        self.root = root
        f = self.rec(root.left,root.right)
        if f:
            return True
        
        return False

107 . Flatten Binary Tree to LinkedList 

class Solution:
    def flatten(self, root: TreeNode) -> None:
        curr = root
        
        while curr:
            if curr.left != None:
                p = curr.left
                while p.right != None:
                    p = p.right
                    
                p.right = curr.right
                
                curr.right = curr.left
                curr.left = None
            
            curr = curr.right


108 . Check if Binary Tree is mirror of itself or not   

Same Question as 106.

109 . Populate Next Right pointers of Tree 

"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def rec(self,node,rip):
        if node == None:
            return None
        
        node.next = rip
        self.rec(node.left,node.right)
        
        if rip == None:
            z = None
            
        else:
            z = rip.left
            
        self.rec(node.right,z)
        return node
        
    
    def connect(self, root: 'Node') -> 'Node':
        self.root = root
        return self.rec(self.root,None)

110 . Search given Key in BST 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rec(self,node):
        if node == None:
            return None
        
        if self.val == node.val:
            return node
        
        if self.val < node.val:
            return self.rec(node.left)
            
        else:
            return self.rec(node.right)
    
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        self.root = root
        self.val = val
        return self.rec(self.root)

111 . Construct BST from given keys (Sorted). 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rec(self,low,high,ind):
        if high < low:
            return None
        
        mid = low+((high-low)//2)
        node = TreeNode()
        node.val = self.nums[mid-1]
        node.left = self.rec(low,mid-1,ind*2)
        node.right = self.rec(mid+1,high,(ind*2)+1)
        return node
    
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        self.nums = nums
        return self.rec(1,len(nums),1)

112 . Check is a BT is BST or not 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rec(self,node,mi,ma):
        if node == None:
            return True
        
        val = node.val
        if val > mi and val < ma:
            return self.rec(node.left,mi,node.val)&self.rec(node.right,node.val,ma)
            
        else:
            return False
    
    def isValidBST(self, root: TreeNode) -> bool:
        self.root = root
        return self.rec(self.root,-1*(10**18),10**18)
        
        
113 . Find LCA of two nodes in BST 

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rec(self,node,p,q):
        if node.val == p.val or node.val == q.val:
            return node
        
        if node.val > p.val and node.val > q.val:
            return self.rec(node.left,p,q)
        
        if node.val < p.val and node.val < q.val:
            return self.rec(node.right,p,q)
        
        return node
    
    
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        self.root = root
        return self.rec(self.root,p,q)
        
114 . Predecessor and Successor

#INORDER PREDECESSOR 

"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given BST
    @param p: the given node
    @return: the in-order predecessor of the given node in the BST
    """
    def ans(self,root,key):
        current = self.search(root,key)
        if current.left != None:
            return self.findMax(current.left)

        res = None
        node = root
        while node != current:
            if node.val < current.val:
                res = node
                node = node.right

            else:
                node = node.left

        return res
            
    def findMax(self,node):
        while node.right != None:
            node = node.right
            
        return node
    
    def search(self,node,key):
        if node.val == key:
            return node
        
        # print(node.val,key)
        if node.val < key:
            return self.search(node.right,key)
            
        return self.search(node.left,key)

    def inorderPredecessor(self, root, p):
        # write your code here
        if root == None:
            return None
            
        self.root = root
        self.key = p 
        return self.ans(root,p.val)

#INORDER SUCCESSOR

import sys
sys.setrecursionlimit(10**6)
# Definition for a  binary tree node
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param A : root node of tree
    # @param B : integer
    # @return the root node in the tree
    
    def ans(self,root,val):
        current = self.search(root,val)
        if current.right != None:
            return self.findMin(current.right)
            
        else:
            res = None
            node = root
            while node != current:
                if node.val < current.val:
                    node = node.right
                    
                else:
                    res = node
                    node = node.left
                    
            return res
    
    def findMin(self,node):
        while node.left != None:
            node = node.left
            
        return node
    
    def search(self,node,val):
        if node.val == val:
            return node
            
        if node.val < val:
            return self.search(node.right,val)
            
        return self.search(node.left,val)
    
    
    def getSuccessor(self, A, B):
        self.root = A
        self.key = B
        return self.ans(self.root,self.key)
        

115 . Floor and Ceil in a BST 

### Similar to INORDER SUCCESSOR AND INORDER PREDECESSOR 

116 . Find K-th smallest and K-th largest element in BST (2 different Questions)

117 . Find a pair with a given sum in BST

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rec(self,node):
        if node == None:
            return
        
        self.rec(node.left)
        dat = node.val
        rem = self.val-dat
        if rem in self.dict:
            self.flag = True
            
        self.dict.add(dat)
        self.rec(node.right)
        return
    
    def findTarget(self, root: TreeNode, k: int) -> bool:
        self.root = root
        self.dict = set() 
        self.flag = False
        self.val = k
        self.rec(root)
        return self.flag

118 . BST iterator 

119 . Size of the largest BST in a Binary Tree

120 . Serialize and deserialize Binary Tree

121 . Convert Binary Search Tree to Sorted Doubly Linked List

122 . Find median in a stream of running integers.

import heapq
class MedianFinder:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.h1 = []
        self.h2 = []
        self.n = 0
        heapq.heapify(self.h1)
        heapq.heapify(self.h2)
        # print(self.h1,"h1")
        # print(self.h2,"h2")
        return

    def addNum(self, num: int) -> None:
        now = self.n+1
        if now//2 > self.n//2:
            if len(self.h1) == 0:
                e = heapq.heappop(self.h2)
                ma = max(e,num)
                mi = min(e,num)
                heapq.heappush(self.h1,-1*mi)
                heapq.heappush(self.h2,ma)
            
            elif num <= -1*self.h1[0]:
                # e = heapq.heappop(self.h2)
                heapq.heappush(self.h1,-1*num)
                # heapq.heappush(self.h2,e)
                
            else:
                e = heapq.heappop(self.h2)
                ma = max(e,num)
                mi = min(e,num)
                heapq.heappush(self.h1,-1*mi)
                heapq.heappush(self.h2,ma)
            
        
        else:
            ele1 = -1*(10**18)
            if len(self.h1) > 0:
                ele1 = -1*self.h1[0]
                
            if num > ele1:
                heapq.heappush(self.h2,num)
                
            else:
                x = -1*heapq.heappop(self.h1)
                heapq.heappush(self.h2,x)
                heapq.heappush(self.h1,-1*num)
                
        self.n = self.n+1
        # print(self.h1,"h1")
        # print(self.h2,"h2")
        return None

    def findMedian(self) -> float:
        # print(self.h1,"h1")
        # print(self.h2,"h2")
        if self.n%2 == 0:
            e1 = -1*self.h1[0]
            e2 = self.h2[0]
            return (e1+e2)/2
        
        return self.h2[0]
        


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()

123 . K-th largest element in a stream. 

124 . Distinct numbers in Window. 

class Solution:
	# @param A : list of integers
	# @param B : integer
	# @return a list of integers
	def dNums(self, A, B):
	    d = {}
	    i = 0
	    n = len(A)
	    while i < B:
	        x = A[i]
	        if x in d:
	            d[x] += 1
	        
	        else:
	            d[x] = 1
	            
	        i = i+1
	        
	    ans = []
	    ans.append(len(d))
	    p1 = 0
	    p2 = i
	    while p2 < n:
	        x = A[p2]
	        if x in d:
	            d[x] += 1
	            
	        else:
	            d[x] = 1
	            
	        d[A[p1]] -= 1
	        if d[A[p1]] == 0:
	            del d[A[p1]]
	            
	        ans.append(len(d))
	        p2 += 1
	        p1 += 1
	        
	    return ans

125 . K-th largest element in an unsorted array. 

#Partition Method
import random

class Solution:
    def rec(self,start,end):
        # print(start,end,self.k)
        ind = random.randrange(start,end+1)
        ele = self.nums[ind]
        self.nums[ind],self.nums[end] = self.nums[end],self.nums[ind]
        p0 = start
        p1 = start
        comp = self.nums[end]
        while p1 < end:
            x = self.nums[p1]
            if x < comp:
                self.nums[p1],self.nums[p0] = self.nums[p0],self.nums[p1]
                p0 += 1
                p1 += 1
                
            else:
                p1 += 1
                
        self.nums[p0],self.nums[end] = self.nums[end],self.nums[p0]
        # print(self.nums)
        if self.k == p0:
            return self.nums[p0]
        
        if self.k < p0:
            return self.rec(start,p0-1)
        
        return self.rec(p0+1,end)
        
    
    def findKthLargest(self, nums: List[int], k: int) -> int:
        self.nums = nums
        self.k = len(self.nums)-k
        return self.rec(0,len(self.nums)-1)

126 . Flood-fill Algorithm

from collections import deque
class Solution:
    def bfs(self,start):
        explored = set()
        visited = {start}
        l = [start]
        queue = deque(l)
        color = self.image[start[0]][start[1]]
        while len(queue) > 0:
            ele = queue.popleft()
            edges = [(ele[0]-1,ele[1]),(ele[0]+1,ele[1]),(ele[0],ele[1]-1),(ele[0],ele[1]+1)]
            self.image[ele[0]][ele[1]] = self.newColor
            explored.add(ele)
            for x in edges:
                if x[0] >= 0 and x[1] >= 0 and x[0] < len(self.image) and x[1] < len(self.image[0]):
                    if x in visited:
                        continue
                        
                    else:
                        if self.image[x[0]][x[1]] == color:
                            visited.add(x)
                            queue.append(x)
                        
        return
    
    
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        self.image = image
        self.start = (sr,sc)
        self.newColor = newColor
        self.bfs(self.start)
        return self.image

127 . Clone a graph (Not that easy as it looks) 

"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution:
    def dfs(self,i):
        if i not in self.visited and i != None:
            if i.val in self.d:
                x = self.d[i.val]
                
            else:
                x = Node(i.val,[])
                self.d[i.val] = x
            
            self.visited.add(i)
            for u in i.neighbors:
                if u in self.visited:
                    x.neighbors.append(self.d[u.val])
                    
                else:
                    if u.val in self.d:
                        x.neighbors.append(self.d[u.val])
                        
                    else:
                        w = Node(u.val,[])
                        self.d[u.val] = w
                        x.neighbors.append(self.d[u.val])
                        self.dfs(u)
                        
            return
            
        return
    
    def cloneGraph(self, node: 'Node') -> 'Node':
        if node == None:
            return None
        
        self.visited = set()
        self.d = {}
        self.dfs(node)
        return self.d[node.val]

128 . DFS
#No need

129 . BFS
#No need

130 . Detect A cycle in Undirected Graph/Directed Graph 

#Undirected Graph is trivial

#Directed Graph

(DFS Approach)
class Solution
{
    private:
   bool dfs(int node,vector<int> adj[],int vis[],int dfsVis[]){
	    vis[node] = 1;
	    dfsVis[node] = 1;
	    for(auto x: adj[node]){
	        if(!vis[x]){
	            if(dfs(x,adj,vis,dfsVis)){
	                return true;
	            }
	        }
	        else if(dfsVis[x] == 1){
	            return true;
	        }
	    }
	    dfsVis[node] = 0;
	    return false;
	}
   
    public:
	//Function to detect cycle in a directed graph.
    
	
	bool isCyclic(int V, vector<int> adj[]) 
	{
	   	// code here
	   	int vis[V],dfsVis[V];
	   	memset(vis,0,sizeof(vis));
	   	memset(dfsVis,0,sizeof(dfsVis));
	   	for(int i = 0; i < V; i++){
	   	    if(!vis[i]){
	   	        if(dfs(i,adj,vis,dfsVis) == 1){
	   	            return true;
	   	        }
	   	    }
	   	}
	   	return false;
	}
};

(BFS APPROACH)

from collections import deque
import sys
input = sys.stdin.readline

#Topological Sort By Kahn's Algoritm

class Solution:
    def kahn(self,indegree,adj,V):
        ans = []
        visited = [0]*V
        stack = deque([])
        for i in range(V):
            x = indegree[i]
            if x == 0 and visited[i] == 0:
                stack.append(i)
            
            while len(stack) != 0:
                e = stack.popleft()
                for j in adj[e]:
                    indegree[j] -= 1
                    if indegree[j] == 0:
                        stack.append(j)
                
                visited[e] = 1
                ans.append(e)
                
        if len(ans) == V:
            return 0
            
        return 1
    
    #Function to detect cycle in a directed graph.
    def isCyclic(self, V, adj):
        # code here
        indegree = [0]*V
        for i in range(len(adj)):
            for j in adj[i]:
                indegree[j] += 1
                
        return self.kahn(indegree,adj,V)


131 . Topo Sort
(Kahn's Algorithm)

from collections import deque
import sys
input = sys.stdin.readline

def kahn(indegree,adj,V):
        ans = []
        visited = [0]*V
        stack = deque([])
        for i in range(V):
            x = indegree[i]
            if x == 0 and visited[i] == 0:
                stack.append(i)
            
            while len(stack) != 0:
                e = stack.popleft()
                for j in adj[e]:
                    indegree[j] -= 1
                    if indegree[j] == 0:
                        stack.append(j)
                
                visited[e] = 1
                ans.append(e)
            
        return ans

(DFS)
def topoSort(self, V, adj):
        def dfs(node):
            visited.add(node)
            if node in graph:
                for x in graph[node]:
                    if x not in visited:
                        dfs(x)
                        
            stack.append(node)
            return
            
        stack = []
        visited = set()
        graph = adj
        n = V
        for i in range(n):
            if i not in visited:
                dfs(i)
                
        return stack[::-1]

132 . Number of islands 

#Graph approach

from collections import deque

def get_number_of_islands(binaryMatrix):
  visited = set()
  n = len(binaryMatrix)
  m = len(binaryMatrix[0])
  ans = 0
  for i in range(n):
    for j in range(m):
      if (i,j) in visited or binaryMatrix[i][j] == 0:
        continue
      
      else:
        ans += 1
        #bfs((i,j),visited,binaryMatrix,n,m)
        start = (i,j)
        queue = deque([start])
        visited.add(start)
        while len(queue) > 0:
          node = queue.popleft()
          i = node[0]
          j = node[1]
          adjacent = [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]
          for child in adjacent:
            x = child[0]
            y = child[1]
            if x < 0 or y < 0 or x >= n or y >= m:
              continue
            
            if child in visited:
              continue
            
            if binaryMatrix[x][y] == 1:
              visited.add(child)
              queue.append(child)
  
  return ans

#(Union Approach)

133 . Bipartite Check (Trivial Question)

134 . SCC(using KosaRaju’s algo) 

#Question 
You are given a graph with N nodes and M directed edges. Find C-D.

Where,

C Sum of number of nodes in all Strongly Connected Components with odd number of nodes.

D Sum of number of nodes in all Strongly Connected Components with even number of nodes.


#Solution

def dfs(node):
    visited.add(node)
    if node not in graph:
        stack.append(node)
        return

    for x in graph[node]:
        if x not in visited:
            dfs(x)

    stack.append(node)
    return

def count_dfs(node):
    cnt = 0
    visited.add(node)
    if node not in graph:
        return cnt

    for x in graph[node]:
        if x not in visited:
            cnt += (1+count_dfs(x))

    return cnt

n,m = map(int,input().split())
graph = {}
for i in range(m):
    a,b = map(int,input().split())
    if a in graph:
        graph[a].append(b)

    else:
        graph[a] = [b]

stack = []
visited = set()
for i in range(1,n+1):
    if i not in visited:
        dfs(i)

c = 0
d = 0
visited = set()
for i in stack:
    if i not in visited:
        ans = 1+count_dfs(i)
        if ans%2:
            c += ans

        else:
            d += ans

print(c-d)

135 . Dijkstra's algorithm

##Inefficient implementation O(V**2)
def getmin(s):
    e = 10**18
    x = -1
    for i in s:
        if i[0] < e:
            e = i[0]
            x = i

    return x

def dijkstra(v):
    s.add((0,v))
    dist[v] = 0
    while len(s) != 0:
        e = getmin(s)
        u = e[1]
        s.remove(e)
        for i in graph[u]:
            v = i
            w = price[(u,v)]
            if dist[v] > dist[u]+w:
                if dist[v] != 10**18:
                    s.remove((dist[v],v))

                dist[v] = dist[u]+w
                s.add((dist[v],v))

    return

136 . Bellman Ford Algo 

137 . Floyd Warshall Algorithm 

138 . MST using Prim’s Algo


#####################################################################################################
Some Extra Problems

*Binary Tree Level Order Traversal

from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if root == None:
            return []
        
        queue = deque([])
        queue.append((root,0))
        ans = []
        for i in range(2001):
            ans.append([])
            
        while len(queue) > 0:
            x = queue.popleft()
            node = x[0]
            level = x[1]
            ans[level].append(node.val)
            if node.left != None:
                queue.append((node.left,level+1))
                
            if node.right != None:
                queue.append((node.right,level+1))
                
        while len(ans) > 0:
            if len(ans[-1]) == 0:
                ans.pop()
                continue
                
            break
                
        return ans

* Largest Cycle

You are given a maze with N cells. Each cell may have multiple entry points but not more than one exit (ie. entry/exit points are unidirectional doors like valves).

The cells are named with an integer value from 0 to N-1.

You need to find the the length of the largest cycle in the maze. Return -1 if there are no cycles.

INPUT FORMAT

First line has the number of cells N
Second line has list of N values of the edge[] array. edge[i] contains the cell number that can be reached from of cell ‘i’ in one step. edge[i] is -1 if the ‘i’th cell doesn’t have an exit.
OUTPUT FORMAT

length of the largest cycle.

Code :

def dfs(node,count):
    if cycle_visited[node] == 1:
        cnt[node] = count
        return
        
    visited[node] = 1
    cycle_visited[node] = 1
    if arr[node] != -1:
        dfs(arr[node],count+1)
        
    cycle_visited[node] = 0
    return

n = int(input())
arr = list(map(int,input().split()))
cnt = [0]*n
visited = [0]*n
cycle_visited = [0]*n
for i in range(n):
    if visited[i] == 0:
        dfs(0,0)
        
ans = 0
for i in cnt:
    ans = max(ans,i)
    
print(ans)